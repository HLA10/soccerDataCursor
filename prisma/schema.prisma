generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model development_comments {
  id        String   @id
  playerId  String
  authorId  String
  date      DateTime @default(now())
  comment   String
  category  String?
  createdAt DateTime @default(now())
  updatedAt DateTime
  users     users    @relation(fields: [authorId], references: [id], onDelete: Cascade)
  players   players  @relation(fields: [playerId], references: [id], onDelete: Cascade)
}

model game_stats {
  id                                        String   @id
  playerId                                  String
  gameId                                    String
  minutes                                   Int      @default(0)
  goals                                     Int      @default(0)
  assists                                   Int      @default(0)
  yellowCards                               Int      @default(0)
  redCards                                   Int      @default(0)
  rating                                    Float?
  createdAt                                 DateTime @default(now())
  updatedAt                                 DateTime
  assistMinutes                             String?
  goalMinutes                               String?
  position                                  String?
  started                                   Boolean  @default(false)
  substitutedBy                             String?
  substitutionMinute                        Int?
  games                                     games    @relation(fields: [gameId], references: [id], onDelete: Cascade)
  players_game_stats_playerIdToplayers      players  @relation("game_stats_playerIdToplayers", fields: [playerId], references: [id], onDelete: Cascade)
  players_game_stats_substitutedByToplayers players? @relation("game_stats_substitutedByToplayers", fields: [substitutedBy], references: [id])

  @@unique([playerId, gameId])
}

model games {
  id                  String       @id
  date                DateTime
  opponent            String
  opponentId          String?
  venue               String
  competition         String
  competitionId       String?
  score               String?
  createdAt           DateTime     @default(now())
  updatedAt           DateTime
  isHome              Boolean?
  teamId              String
  game_stats          game_stats[]
  teams               teams        @relation(fields: [teamId], references: [id], onDelete: Cascade)
  competitionRelation competition? @relation(fields: [competitionId], references: [id])
  opponentClub        opponent?    @relation(fields: [opponentId], references: [id])
}

model illnesses {
  id          String        @id
  playerId    String
  type        String
  startDate   DateTime
  endDate     DateTime?
  status      IllnessStatus @default(ACTIVE)
  description String?
  createdAt   DateTime      @default(now())
  updatedAt   DateTime
  players     players       @relation(fields: [playerId], references: [id], onDelete: Cascade)
}

model injuries {
  id          String       @id
  playerId    String
  type        String
  startDate   DateTime
  endDate     DateTime?
  status      InjuryStatus @default(ACTIVE)
  description String?
  createdAt   DateTime     @default(now())
  updatedAt   DateTime
  players     players      @relation(fields: [playerId], references: [id], onDelete: Cascade)
}

model players {
  id                                           String                 @id
  name                                         String
  position                                     String
  jerseyNumber                                 Int?
  dateOfBirth                                  DateTime?
  photo                                        String?
  createdAt                                    DateTime               @default(now())
  updatedAt                                    DateTime
  primaryTeamId                                String?
  development_comments                         development_comments[]
  game_stats_game_stats_playerIdToplayers      game_stats[]           @relation("game_stats_playerIdToplayers")
  game_stats_game_stats_substitutedByToplayers game_stats[]           @relation("game_stats_substitutedByToplayers")
  illnesses                                    illnesses[]
  injuries                                     injuries[]
  teams                                        teams?                 @relation(fields: [primaryTeamId], references: [id])
  team_players                                 team_players[]
  tournament_stats                             tournament_stats[]
}

model team_players {
  id                 String   @id
  playerId           String
  teamId             String
  isBorrowed         Boolean  @default(false)
  borrowedFromTeamId String?
  createdAt          DateTime @default(now())
  updatedAt          DateTime
  players            players  @relation(fields: [playerId], references: [id], onDelete: Cascade)
  teams              teams    @relation(fields: [teamId], references: [id], onDelete: Cascade)

  @@unique([playerId, teamId])
}

model teams {
  id               String            @id
  name             String
  code             String?           @unique
  createdAt        DateTime          @default(now())
  updatedAt        DateTime
  games            games[]
  players          players[]
  team_players     team_players[]
  tournaments      tournaments[]
  users            users[]
  competitions     competition[]
  competitionTeams competitionTeam[]
  opponentTeams    opponentTeam[]
 invitations invitation[] @relation("TeamInvitations")

}

model tournament_stats {
  id           String      @id
  playerId     String
  tournamentId String
  minutes      Int         @default(0)
  goals        Int         @default(0)
  assists      Int         @default(0)
  appearances  Int         @default(0)
  createdAt    DateTime    @default(now())
  updatedAt    DateTime
  players      players     @relation(fields: [playerId], references: [id], onDelete: Cascade)
  tournaments  tournaments @relation(fields: [tournamentId], references: [id], onDelete: Cascade)

  @@unique([playerId, tournamentId])
}

model tournaments {
  id               String             @id
  name             String
  season           String
  startDate        DateTime
  endDate          DateTime?
  type             String
  createdAt        DateTime           @default(now())
  updatedAt        DateTime
  teamId           String
  tournament_stats tournament_stats[]
  teams            teams              @relation(fields: [teamId], references: [id], onDelete: Cascade)
}

model users {
  id                   String                 @id
  email                String                 @unique
  password             String
  name                 String?
  role                 Role                   @default(VIEWER)
  createdAt            DateTime               @default(now())
  updatedAt            DateTime
  teamId               String?
  status               UserStatus             @default(ACTIVE)
  playerId             String?
  invitedBy            String?
  emailVerified        DateTime?
  development_comments development_comments[]
  teams                teams?                 @relation(fields: [teamId], references: [id])

  @@index([status])
}

model clubLogo {
  id        String   @id @default(uuid())
  clubName  String   @unique
  logo      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model competition {
  id          String            @id @default(uuid())
  name        String
  type        String
  customType  String?
  season      String
  startDate   DateTime?
  endDate     DateTime?
  description String?
  logo        String?
  location    String?
  teamId      String?
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt
  team        teams?            @relation(fields: [teamId], references: [id])
  teams       competitionTeam[]
  games       games[]

  @@index([teamId])
  @@index([season])
}

model competitionTeam {
  id            String      @id @default(uuid())
  competitionId String
  teamId        String
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  competition   competition @relation(fields: [competitionId], references: [id], onDelete: Cascade)
  team          teams       @relation(fields: [teamId], references: [id], onDelete: Cascade)

  @@unique([competitionId, teamId])
}

model opponent {
  id             String          @id @default(uuid())
  name           String
  location       String?
  homeField      String?
  primaryColor   String?
  secondaryColor String?
  logo           String?
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
  games          games[]
  teams          opponentTeam[]
  scoutedPlayers scoutedPlayer[]
}

model opponentTeam {
  id         String   @id @default(uuid())
  opponentId String
  teamId     String?
  name       String?
  gender     String?
  age        String?
  teamColor  String?
  homeField  String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  opponent   opponent @relation(fields: [opponentId], references: [id], onDelete: Cascade)
  team       teams?   @relation(fields: [teamId], references: [id], onDelete: Cascade)

  @@unique([opponentId, teamId])
}

model scoutedPlayer {
  id         String   @id @default(uuid())
  opponentId String
  playerId   String
  gameId     String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  opponent   opponent @relation(fields: [opponentId], references: [id], onDelete: Cascade)

  @@index([opponentId])
}

model invitation {
  id        String   @id @default(uuid())
  token     String   @unique
  email     String?
  teamId    String
  role      Role?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  team teams @relation("TeamInvitations", fields: [teamId], references: [id], onDelete: Cascade)

}

enum IllnessStatus {
  ACTIVE
  RECOVERED
  INACTIVE
}

enum InjuryStatus {
  ACTIVE
  RECOVERED
  INACTIVE
}

enum Role {
  ADMIN
  COACH
  VIEWER
}

enum UserStatus {
  PENDING
  ACTIVE
  REJECTED
}
